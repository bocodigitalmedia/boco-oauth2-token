// Generated by CoffeeScript 1.6.3
(function() {
  var AccessToken, AccessTokenRepository, AccessTokenService, Async, MS;

  Async = require('async');

  AccessTokenRepository = require('./AccessTokenRepository');

  AccessToken = require('./AccessToken');

  MS = require('boco-time').MilliSeconds;

  AccessTokenService = (function() {
    AccessTokenService.DEFAULT_ACCESS_TOKEN_EXPIRY = MS.hours(4);

    AccessTokenService.DEFAULT_REFRESH_TOKEN_EXPIRY = MS.weeks(2);

    function AccessTokenService(props) {
      if (props == null) {
        props = {};
      }
      this.accessTokenRepository = props.accessTokenRepository;
      this.accessTokenExpiry = props.accessTokenExpiry;
      this.accessTokenType = props.accessTokenType;
      this.setDefaults();
    }

    AccessTokenService.prototype.setDefaults = function() {
      if (this.accessTokenType == null) {
        this.accessTokenType = "bearer";
      }
      if (this.accessTokenExpiry == null) {
        this.accessTokenExpiry = this.constructor.DEFAULT_ACCESS_TOKEN_EXPIRY;
      }
      if (this.refreshTokenExpiry == null) {
        this.refreshTokenExpiry = this.constructor.DEFAULT_REFRESH_TOKEN_EXPIRY;
      }
      return this.accessTokenRepository != null ? this.accessTokenRepository : this.accessTokenRepository = new AccessTokenRepository();
    };

    AccessTokenService.prototype.constructAccessToken = function(props) {
      var token;
      if (props == null) {
        props = {};
      }
      return token = new AccessToken(props);
    };

    AccessTokenService.prototype.generateAccessTokenString = function(bytes, encoding) {
      if (bytes == null) {
        bytes = 16;
      }
      if (encoding == null) {
        encoding = 'base64';
      }
      return require('crypto').randomBytes(bytes).toString(encoding);
    };

    AccessTokenService.prototype.generateRefreshTokenString = function(bytes, encoding) {
      if (bytes == null) {
        bytes = 16;
      }
      if (encoding == null) {
        encoding = 'base64';
      }
      return require('crypto').randomBytes(bytes).toString(encoding);
    };

    AccessTokenService.prototype.grantAccessToken = function(params, callback) {
      var accessToken;
      if (params == null) {
        params = {};
      }
      accessToken = this.constructAccessToken({
        type: this.accessTokenType,
        clientId: params.clientId,
        userId: params.userId,
        expiresIn: this.accessTokenExpiry
      });
      accessToken.value = this.generateAccessTokenString();
      accessToken.refreshToken = this.generateRefreshTokenString();
      return this.accessTokenRepository.store(accessToken, function(error, accessToken) {
        if (error != null) {
          return callback(error);
        }
        return callback(null, accessToken);
      });
    };

    AccessTokenService.prototype.refreshAccessToken = function(params, callback) {
      var assertAccessTokenBelongsToClient, assertAccessTokenFound, constructNewAccessToken, findAccessToken, markOldAccessTokenAsRefreshed, steps, storeNewAccessToken, _accessTokenRepository, _clientId, _newAccessToken, _oldAccessToken, _refreshToken, _service;
      if (params == null) {
        params = {};
      }
      _clientId = params.clientId;
      _refreshToken = params.refreshToken;
      _service = this;
      _accessTokenRepository = this.accessTokenRepository;
      _oldAccessToken = null;
      _newAccessToken = null;
      findAccessToken = function(done) {
        var query;
        query = {
          refreshToken: _refreshToken
        };
        return _accessTokenRepository.findByRefreshToken(query, function(error, accessToken) {
          if (error != null) {
            return done(error);
          }
          _oldAccessToken = accessToken;
          return done();
        });
      };
      assertAccessTokenFound = function(done) {
        var error;
        error = Error("No token found with this refresh token");
        if (_oldAccessToken == null) {
          return done(error);
        }
        return done();
      };
      assertAccessTokenBelongsToClient = function(done) {
        var error;
        error = Error("Access token does not belong to this client");
        if (_oldAccessToken.clientId !== _clientId) {
          return done(error);
        }
        return done();
      };
      constructNewAccessToken = function(done) {
        var newAccessToken;
        newAccessToken = _service.constructAccessToken({
          type: _oldAccessToken.type,
          clientId: _oldAccessToken.clientId,
          userId: _oldAccessToken.userId,
          expiresIn: _oldAccessToken.expiresIn
        });
        newAccessToken.value = _service.generateAccessTokenString();
        newAccessToken.refreshToken = _service.generateRefreshTokenString();
        _newAccessToken = newAccessToken;
        return done();
      };
      storeNewAccessToken = function(done) {
        return _accessTokenRepository.store(_newAccessToken, function(error, accessToken) {
          if (error != null) {
            return done(error);
          }
          _newAccessToken = accessToken;
          return done();
        });
      };
      markOldAccessTokenAsRefreshed = function(done) {
        _oldAccessToken.hasBeenRefreshed = true;
        return _accessTokenRepository.store(_oldAccessToken, function(error) {
          if (error != null) {
            return done(error);
          }
          return done();
        });
      };
      steps = [findAccessToken, assertAccessTokenFound, assertAccessTokenBelongsToClient, constructNewAccessToken, storeNewAccessToken, markOldAccessTokenAsRefreshed];
      return Async.series(steps, function(error) {
        if (error != null) {
          return callback(error);
        }
        return callback(null, _newAccessToken);
      });
    };

    return AccessTokenService;

  })();

  module.exports = AccessTokenService;

}).call(this);

/*
//@ sourceMappingURL=AccessTokenService.map
*/
